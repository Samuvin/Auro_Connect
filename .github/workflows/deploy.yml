name: üöÄ Deploy Application

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip pre-deployment tests'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '18'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Pre-deployment tests
  pre-deploy-tests:
    name: üß™ Pre-deployment Tests
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_tests != 'true'
    
    steps:
      - name: üîç Checkout Repository
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: üî® Install Dependencies
        run: |
          npm install
          cd frontend && npm install
          cd ../backend && npm install

      - name: üß™ Run Critical Tests
        run: |
          # Run only critical/smoke tests for faster deployment
          cd backend && npm test -- --testNamePattern="(auth|database)" --passWithNoTests
          cd ../frontend && npm test -- --testNamePattern="(login|critical)" --watchAll=false --passWithNoTests

  # Build and containerize
  build-and-push:
    name: üèóÔ∏è Build and Push Images
    runs-on: ubuntu-latest
    needs: [pre-deploy-tests]
    if: always() && (needs.pre-deploy-tests.result == 'success' || github.event.inputs.skip_tests == 'true')
    outputs:
      frontend-image: ${{ steps.meta-frontend.outputs.tags }}
      backend-image: ${{ steps.meta-backend.outputs.tags }}
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: üîç Checkout Repository
        uses: actions/checkout@v4

      - name: üìã Extract Version
        id: version
        run: |
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=latest
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: üîê Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Build Frontend
      - name: üìã Extract Frontend Metadata
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend
          tags: |
            type=ref,event=branch
            type=ref,event=tag
            type=raw,value=latest,enable={{is_default_branch}}

      - name: üèóÔ∏è Build and Push Frontend Image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Build Backend
      - name: üìã Extract Backend Metadata
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend
          tags: |
            type=ref,event=branch
            type=ref,event=tag
            type=raw,value=latest,enable={{is_default_branch}}

      - name: üèóÔ∏è Build and Push Backend Image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Deploy to Staging
  deploy-staging:
    name: üöÄ Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-and-push]
    environment: 
      name: staging
      url: https://staging.yourapp.com
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'staging'

    steps:
      - name: üîç Checkout Repository
        uses: actions/checkout@v4

      - name: üöÄ Deploy to Staging Environment
        run: |
          echo "Deploying to staging..."
          echo "Frontend Image: ${{ needs.build-and-push.outputs.frontend-image }}"
          echo "Backend Image: ${{ needs.build-and-push.outputs.backend-image }}"
          echo "Version: ${{ needs.build-and-push.outputs.version }}"
          
          # Here you would add your actual deployment commands
          # Examples:
          # - kubectl apply -f k8s/staging/
          # - helm upgrade staging-release ./helm-chart
          # - docker-compose -f docker-compose.staging.yml up -d
          # - scp deployment files to staging server
          # - run deployment scripts

      - name: üîç Run Staging Health Checks
        run: |
          echo "Running health checks..."
          # Add actual health check commands here
          # curl -f https://staging.yourapp.com/api/health
          # npm run test:staging:smoke

      - name: üì¢ Notify Staging Deployment
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Staging deployment successful"
          else
            echo "‚ùå Staging deployment failed"
          fi

  # Deploy to Production (requires approval)
  deploy-production:
    name: üè≠ Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-staging]
    environment: 
      name: production
      url: https://yourapp.com
    if: startsWith(github.ref, 'refs/tags/') || github.event.inputs.environment == 'production'

    steps:
      - name: üîç Checkout Repository
        uses: actions/checkout@v4

      - name: üìã Pre-Production Checklist
        run: |
          echo "## üöÄ Production Deployment Checklist" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ All tests passed" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Images built and pushed" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Staging deployment successful" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Manual approval received" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deploying Version:** ${{ needs.build-and-push.outputs.version }}" >> $GITHUB_STEP_SUMMARY

      - name: üè≠ Deploy to Production Environment
        run: |
          echo "Deploying to production..."
          echo "Frontend Image: ${{ needs.build-and-push.outputs.frontend-image }}"
          echo "Backend Image: ${{ needs.build-and-push.outputs.backend-image }}"
          echo "Version: ${{ needs.build-and-push.outputs.version }}"
          
          # Add your production deployment commands here
          # Examples:
          # - kubectl apply -f k8s/production/
          # - helm upgrade production-release ./helm-chart
          # - blue-green deployment scripts
          # - canary deployment with traffic splitting

      - name: üîç Run Production Health Checks
        run: |
          echo "Running production health checks..."
          # Add comprehensive production health checks
          # curl -f https://yourapp.com/api/health
          # npm run test:production:smoke
          # Check metrics and monitoring

      - name: üìä Post-Deployment Monitoring
        run: |
          echo "Setting up post-deployment monitoring..."
          # Set up monitoring alerts
          # Check error rates
          # Verify key metrics

  # Rollback capability
  rollback:
    name: ‚è™ Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && (needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure')
    needs: [deploy-staging, deploy-production]
    environment: 
      name: ${{ github.event.inputs.environment || 'staging' }}

    steps:
      - name: üîç Checkout Repository
        uses: actions/checkout@v4

      - name: ‚è™ Perform Rollback
        run: |
          echo "Performing rollback..."
          # Add rollback commands here
          # kubectl rollout undo deployment/app
          # helm rollback release-name
          # Switch traffic back to previous version

      - name: üö® Notify Rollback
        run: |
          echo "üö® Rollback completed for failed deployment"

  # Deployment notification
  notify-deployment:
    name: üì¢ Deployment Notification
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()

    steps:
      - name: üì¢ Send Deployment Notification
        uses: actions/github-script@v7
        with:
          script: |
            const stagingStatus = '${{ needs.deploy-staging.result }}';
            const productionStatus = '${{ needs.deploy-production.result }}';
            
            let message = '## üöÄ Deployment Summary\n\n';
            
            if (stagingStatus === 'success') {
              message += '‚úÖ **Staging**: Deployed successfully\n';
            } else if (stagingStatus === 'failure') {
              message += '‚ùå **Staging**: Deployment failed\n';
            } else {
              message += '‚è≠Ô∏è **Staging**: Skipped\n';
            }
            
            if (productionStatus === 'success') {
              message += '‚úÖ **Production**: Deployed successfully\n';
            } else if (productionStatus === 'failure') {
              message += '‚ùå **Production**: Deployment failed\n';
            } else {
              message += '‚è≠Ô∏è **Production**: Skipped\n';
            }
            
            message += '\n**Version**: ${{ needs.build-and-push.outputs.version }}\n';
            message += '**Commit**: ${{ github.sha }}\n';
            
            console.log(message);
            
            // Here you could send to Slack, Discord, etc.
            // await fetch(process.env.SLACK_WEBHOOK_URL, {
            //   method: 'POST',
            //   headers: { 'Content-Type': 'application/json' },
            //   body: JSON.stringify({ text: message })
            // }); 